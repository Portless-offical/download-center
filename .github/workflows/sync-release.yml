# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Sync Releases from R2

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to sync (leave empty for latest)'
        required: false
        type: string
      sync_all:
        description: 'Sync all versions from R2'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: write

env:
  CARGO_TERM_COLOR: always

jobs:
  prepare:
    name: Prepare Sync
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    outputs:
      version: ${{ steps.detect. outputs.version }}
      versions: ${{ steps.detect.outputs. versions }}
      should_sync: ${{ steps.detect.outputs.should_sync }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4. 2.2
        with:
          fetch-depth: 0

      - name: Install AWS CLI
        run: |
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2. zip"
          unzip -q awscliv2.zip
          sudo ./aws/install --update

      - name: Validate R2 Configuration
        id: validate
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_ENDPOINT_URL: ${{ secrets.R2_ENDPOINT_URL }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
        run: |
          set -euo pipefail

          echo "=== Validating R2 Configuration ==="
          
          # Check if secrets are set
          if [[ -z "$AWS_ACCESS_KEY_ID" ]]; then
            echo "::error::R2_ACCESS_KEY_ID secret is not set"
            exit 1
          fi
          
          if [[ -z "$AWS_SECRET_ACCESS_KEY" ]]; then
            echo "::error::R2_SECRET_ACCESS_KEY secret is not set"
            exit 1
          fi
          
          if [[ -z "$R2_ENDPOINT_URL" ]]; then
            echo "::error::R2_ENDPOINT_URL secret is not set"
            exit 1
          fi
          
          if [[ -z "$R2_BUCKET_NAME" ]]; then
            echo "::error::R2_BUCKET_NAME secret is not set"
            exit 1
          fi

          # Validate endpoint URL format
          if [[ !  "$R2_ENDPOINT_URL" =~ ^https?:// ]]; then
            echo "::error::R2_ENDPOINT_URL must start with http:// or https://"
            exit 1
          fi

          echo "✓ AWS_ACCESS_KEY_ID is set (length: ${#AWS_ACCESS_KEY_ID})"
          echo "✓ AWS_SECRET_ACCESS_KEY is set (length: ${#AWS_SECRET_ACCESS_KEY})"
          echo "✓ R2_ENDPOINT_URL: $R2_ENDPOINT_URL"
          echo "✓ R2_BUCKET_NAME: $R2_BUCKET_NAME"
          
          # Test AWS CLI connection
          echo ""
          echo "=== Testing AWS CLI Connection ==="
          aws --version
          
          echo ""
          echo "Testing connection to R2..."
          if aws s3 ls "s3://$R2_BUCKET_NAME" \
            --endpoint-url "$R2_ENDPOINT_URL" \
            --region auto 2>&1 | head -20; then
            echo "✓ Successfully connected to R2 bucket"
          else
            echo "::error::Failed to connect to R2 bucket"
            echo "Please verify:"
            echo "  - R2_ACCESS_KEY_ID is correct"
            echo "  - R2_SECRET_ACCESS_KEY is correct"
            echo "  - R2_ENDPOINT_URL is correct (format: https://xxxx.r2.cloudflarestorage.com)"
            echo "  - R2_BUCKET_NAME is correct"
            exit 1
          fi

      - name: Detect version to sync
        id: detect
        if: success()
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_ENDPOINT_URL: ${{ secrets.R2_ENDPOINT_URL }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
          INPUT_VERSION: ${{ inputs.version }}
          SYNC_ALL: ${{ inputs.sync_all }}
        run: |
          set -euo pipefail

          echo "=== Detecting Version to Sync ==="

          if [[ "$SYNC_ALL" == "true" ]]; then
            echo "Syncing all versions from R2..."
            
            # List all version directories
            echo "Fetching list of versions from R2..."
            VERSIONS=$(aws s3api list-objects-v2 \
              --bucket "$R2_BUCKET_NAME" \
              --prefix "releases/" \
              --delimiter "/" \
              --endpoint-url "$R2_ENDPOINT_URL" \
              --region auto \
              --query 'CommonPrefixes[]. Prefix' \
              --output text 2>&1 | sed 's|releases/||g; s|/||g' | tr ' ' ',' | sed 's/,$//' || true)
            
            if [[ -z "$VERSIONS" ]]; then
              echo "::error::No versions found in R2"
              echo "should_sync=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            
            echo "versions=$VERSIONS" >> "$GITHUB_OUTPUT"
            echo "should_sync=true" >> "$GITHUB_OUTPUT"
            echo "Detected versions: $VERSIONS"
            
          elif [[ -n "$INPUT_VERSION" ]]; then
            echo "Using specified version: $INPUT_VERSION"
            echo "version=$INPUT_VERSION" >> "$GITHUB_OUTPUT"
            echo "should_sync=true" >> "$GITHUB_OUTPUT"
            
          else
            # Get latest version from releases/latest. json
            echo "Checking for releases/latest.json in R2..."
            
            if aws s3api head-object \
              --bucket "$R2_BUCKET_NAME" \
              --key "releases/latest.json" \
              --endpoint-url "$R2_ENDPOINT_URL" \
              --region auto 2>/dev/null; then
              
              echo "Found releases/latest.json, downloading..."
              aws s3 cp "s3://$R2_BUCKET_NAME/releases/latest.json" /tmp/latest.json \
                --endpoint-url "$R2_ENDPOINT_URL" \
                --region auto \
                --only-show-errors
              
              LATEST_VERSION=$(jq -r '.version' /tmp/latest.json)
              echo "version=$LATEST_VERSION" >> "$GITHUB_OUTPUT"
              echo "should_sync=true" >> "$GITHUB_OUTPUT"
              echo "Latest version from R2: $LATEST_VERSION"
              
            else
              echo "releases/latest.json not found, falling back to listing all versions..."
              
              # Fallback: list all versions and get the latest
              LATEST_VERSION=$(aws s3api list-objects-v2 \
                --bucket "$R2_BUCKET_NAME" \
                --prefix "releases/" \
                --delimiter "/" \
                --endpoint-url "$R2_ENDPOINT_URL" \
                --region auto \
                --query 'CommonPrefixes[].Prefix' \
                --output text 2>&1 | sed 's|releases/||g; s|/||g' | sort -V | tail -1 || true)
              
              if [[ -z "$LATEST_VERSION" ]]; then
                echo "::error::No releases found in R2"
                echo "should_sync=false" >> "$GITHUB_OUTPUT"
                exit 0
              fi
              
              echo "version=$LATEST_VERSION" >> "$GITHUB_OUTPUT"
              echo "should_sync=true" >> "$GITHUB_OUTPUT"
              echo "Latest version detected: $LATEST_VERSION"
            fi
          fi

  sync:
    name: Sync Version (${{ matrix.version }})
    needs: prepare
    if: needs.prepare.outputs.should_sync == 'true'
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        version: ${{ fromJson(format('["{0}"]', needs.prepare.outputs.version != '' && needs.prepare.outputs.version || needs.prepare.outputs.versions)) }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4. 2.2

      - name: Install AWS CLI
        run: |
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          sudo ./aws/install --update

      - name: Download release artifacts from R2
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets. R2_SECRET_ACCESS_KEY }}
          R2_ENDPOINT_URL: ${{ secrets.R2_ENDPOINT_URL }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
          VERSION: ${{ matrix.version }}
        run: |
          set -euo pipefail

          RELEASE_DIR="binaries/${VERSION}"
          mkdir -p "${RELEASE_DIR}"

          echo "=== Downloading artifacts for ${VERSION} ==="
          
          # List all files in the version directory
          echo "Fetching file list from R2..."
          aws s3api list-objects-v2 \
            --bucket "$R2_BUCKET_NAME" \
            --prefix "releases/${VERSION}/" \
            --endpoint-url "$R2_ENDPOINT_URL" \
            --region auto \
            --output json > /tmp/r2_listing.json

          echo "Files found:"
          jq -r '.Contents[]?.Key' /tmp/r2_listing.json | head -20

          # Download each file
          python3 << 'PYTHON_SCRIPT'
          import json
          import subprocess
          import os
          import sys

          version = os.environ['VERSION']
          bucket = os.environ['R2_BUCKET_NAME']
          endpoint = os.environ['R2_ENDPOINT_URL']
          release_dir = f"binaries/{version}"

          with open('/tmp/r2_listing.json', 'r') as f:
              data = json.load(f)

          file_count = 0
          if 'Contents' in data:
              for obj in data['Contents']:
                  key = obj['Key']
                  filename = os.path.basename(key)
                  
                  # Skip manifest files and empty keys
                  if filename.endswith('.json') or not filename:
                      continue
                  
                  local_path = os.path.join(release_dir, filename)
                  
                  print(f"Downloading {filename}...")
                  
                  cmd = [
                      'aws', 's3', 'cp',
                      f"s3://{bucket}/{key}",
                      local_path,
                      '--endpoint-url', endpoint,
                      '--region', 'auto'
                  ]
                  
                  try:
                      result = subprocess.run(cmd, capture_output=True, text=True)
                      if result.returncode == 0:
                          print(f"✓ Downloaded {filename}")
                          file_count += 1
                      else:
                          print(f"✗ Failed to download {filename}")
                          print(result.stderr)
                  except Exception as e:
                      print(f"✗ Error downloading {filename}: {e}")
          
          print(f"\nTotal files downloaded: {file_count}")
          if file_count == 0:
              print("WARNING: No files were downloaded.  This may be expected if no release artifacts exist.")
          
          PYTHON_SCRIPT

      - name: Generate manifest for version
        env:
          VERSION: ${{ matrix.version }}
          R2_PUBLIC_URL: ${{ secrets.R2_PUBLIC_URL }}
        run: |
          set -euo pipefail

          RELEASE_DIR="binaries/${VERSION}"
          
          echo "=== Generating manifest for ${VERSION} ==="

          python3 << 'PYTHON_SCRIPT'
          import json
          import os
          import glob
          from datetime import datetime

          version = os.environ['VERSION']
          public_url = os.environ. get('R2_PUBLIC_URL', '').rstrip('/')
          release_dir = f"binaries/{version}"

          platform_map = {
              '. dmg': 'darwin',
              '.AppImage': 'linux',
              '. deb': 'linux',
              '.rpm': 'linux',
              '. msi': 'windows',
              '.exe': 'windows'
          }

          assets = []
          
          # Find all files in the release directory
          for filepath in sorted(glob.glob(f"{release_dir}/*")):
              if os.path.isfile(filepath):
                  filename = os.path.basename(filepath)
                  
                  # Skip manifest
                  if filename == 'manifest.json':
                      continue
                  
                  size = os.path.getsize(filepath)
                  
                  # Determine platform
                  platform = 'unknown'
                  for ext, plat in platform_map.items():
                      if filename.endswith(ext):
                          platform = plat
                          break
                  
                  # Build download URL
                  url = f"{public_url}/{release_dir}/{filename}" if public_url else f"{release_dir}/{filename}"
                  
                  assets.append({
                      "filename": filename,
                      "size": size,
                      "platform": platform,
                      "url": url
                  })
          
          manifest = {
              "version": version,
              "released_at": datetime.utcnow().isoformat() + "Z",
              "assets": assets
          }
          
          manifest_path = f"{release_dir}/manifest.json"
          with open(manifest_path, 'w') as f:
              json.dump(manifest, f, indent=2)
          
          print(f"Generated manifest with {len(assets)} assets")
          print(json.dumps(manifest, indent=2))
          
          PYTHON_SCRIPT

      - name: List downloaded files
        run: |
          RELEASE_DIR="binaries/${{ matrix.version }}"
          if [[ -d "$RELEASE_DIR" ]]; then
            echo "Files in $RELEASE_DIR:"
            ls -lh "$RELEASE_DIR/"
          else
            echo "Release directory not found: $RELEASE_DIR"
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        if: success()
        with:
          name: release-${{ matrix.version }}
          path: binaries/${{ matrix.version }}/
          retention-days: 1

  commit-and-push:
    name: Commit and Push Changes
    needs: [prepare, sync]
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    if: success()
    
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Download all artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          path: . 

      - name: Setup git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github. com"

      - name: Create commit for synced releases
        run: |
          set -euo pipefail

          if [[ -z "$(git status --porcelain)" ]]; then
            echo "No changes to commit"
            exit 0
          fi

          git add binaries/ || true
          git commit -m "chore: sync releases from R2 storage" || true
          git push origin HEAD || true

      - name: Create GitHub releases
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSIONS: ${{ needs.prepare.outputs.versions }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          set -euo pipefail

          # Determine which versions to create releases for
          if [[ -n "$VERSIONS" ]]; then
            RELEASE_VERSIONS="${VERSIONS}"
          else
            RELEASE_VERSIONS="${VERSION}"
          fi

          echo "Creating/updating releases for: $RELEASE_VERSIONS"
          
          for RELEASE_VERSION in ${RELEASE_VERSIONS//,/ }; do
            RELEASE_DIR="release-${RELEASE_VERSION}"
            
            if [[ !  -d "$RELEASE_DIR" ]]; then
              echo "Release directory not found: $RELEASE_DIR"
              continue
            fi

            echo "Processing release $RELEASE_VERSION..."
            
            # Check if release already exists
            if gh release view "$RELEASE_VERSION" 2>/dev/null; then
              echo "Release $RELEASE_VERSION already exists, skipping"
              continue
            fi

            # Collect all files for this release (excluding manifest)
            FILES=$(find "$RELEASE_DIR" -maxdepth 1 -type f !  -name "manifest.json" | head -20)

            if [[ -z "$FILES" ]]; then
              echo "No files found for release $RELEASE_VERSION"
              continue
            fi

            # Create release
            echo "Creating release $RELEASE_VERSION..."
            if gh release create "$RELEASE_VERSION" \
              --title "Portless $RELEASE_VERSION" \
              --notes "Release synchronized from R2 storage" \
              --draft=false \
              --prerelease=false \
              $FILES 2>&1; then
              echo "✓ Created release $RELEASE_VERSION"
            else
              echo "⚠ Release creation returned non-zero, but continuing..."
            fi
          done

  update-latest:
    name: Update Latest Release
    needs: [prepare, commit-and-push]
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    if: success()
    
    steps:
      - name: Install AWS CLI
        run: |
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          sudo ./aws/install --update

      - name: Update latest reference in R2
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_ENDPOINT_URL: ${{ secrets.R2_ENDPOINT_URL }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
          R2_PUBLIC_URL: ${{ secrets.R2_PUBLIC_URL }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          set -euo pipefail

          if [[ -z "$VERSION" ]]; then
            echo "::error::Version not determined"
            exit 1
          fi

          echo "=== Updating latest reference for ${VERSION} ==="

          # Generate latest. json
          cat > /tmp/latest.json << EOF
          {
            "version": "${VERSION}",
            "download_url": "${R2_PUBLIC_URL}/releases/${VERSION}",
            "binaries_url": "${R2_PUBLIC_URL}/binaries/${VERSION}",
            "released_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

          echo "Latest metadata:"
          cat /tmp/latest.json

          # Upload latest.json to multiple locations for easy access
          echo ""
          echo "Uploading to s3://${R2_BUCKET_NAME}/latest. json..."
          aws s3 cp /tmp/latest.json "s3://${R2_BUCKET_NAME}/latest.json" \
            --endpoint-url "${R2_ENDPOINT_URL}" \
            --region auto \
            --content-type "application/json" \
            --cache-control "max-age=300"

          echo "Uploading to s3://${R2_BUCKET_NAME}/releases/latest.json..."
          aws s3 cp /tmp/latest. json "s3://${R2_BUCKET_NAME}/releases/latest.json" \
            --endpoint-url "${R2_ENDPOINT_URL}" \
            --region auto \
            --content-type "application/json" \
            --cache-control "max-age=300"

          echo "✓ Latest version reference updated: ${VERSION}"
          echo ""
          echo "Access points:"
          echo "  - Latest metadata: ${R2_PUBLIC_URL}/latest.json"
          echo "  - Latest metadata: ${R2_PUBLIC_URL}/releases/latest.json"
          echo "  - Binaries: ${R2_PUBLIC_URL}/binaries/${VERSION}/"
          echo "  - Releases: ${R2_PUBLIC_URL}/releases/${VERSION}/"

  notify-success:
    name: Notify Success
    needs: [prepare, update-latest]
    runs-on: ubuntu-22.04
    if: success()
    
    steps:
      - name: Log success
        run: |
          echo "✓ Release sync workflow completed successfully"
          echo ""
          echo "Version: ${{ needs.prepare.outputs.version }}"
          echo "Sync completed at: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
